#include<stdio.h>
#define TRUE 1
#define FALSE 0

#define MAX_VERTICES 8
#define INF 1000L

int weight[MAX_VERTICES][MAX_VERTICES] =
{
	{ 0,10,INF,6,INF,INF,INF,1 },	//0 : 1, 3, 7
	{ 10,0,4,INF,INF,2,INF,INF },	//1 : 0, 5, 2
	{ INF,4,0,11,INF,7,INF,INF },	//2 : 1, 5, 3
	{ 6,INF,11,0,INF,INF,INF,3 },	//3 : 0, 7, 2
	{ INF,INF,INF,INF,0,5,INF,8 },	//4 : 5, 7
	{ INF,2,7,INF,5,0,9,INF },		//5 : 1, 2, 4, 6
	{ INF,INF,INF,INF,INF,9,0,12 },	//6 : 5, 7
	{ 1,INF,INF,3,8,INF,12,0 }		//7 : 0, 3, 4, 6
};
// 437P QUIZ 그림


int selected[MAX_VERTICES];	//뽑히면 1 초기화 0
int dist[MAX_VERTICES];		//각 정점에서 갈 수 있는 최소 가중치 like 거리 (distance)

//dist와 selected를 초기화 시킴
void init(int s, int n)
{
	int u;

	for (u = 0;u<n;u++)
		dist[u] = INF;

	dist[s] = 0;	//첫 시작 정점은 0으로 만듬

	for (u = 0;u<n;u++)
		selected[u] = FALSE;	//다 FALSE로 초기화
}

//최소 가중치를 찾아주는 함수
int get_min_vertex(int n)
{
	int v, i;
	for (i = 0;i<n;i++)
		if (!selected[i])	//selected가 아직 안뽑혔으면 검사 -> selected가 아직 0이면	   -> 그값중에 dist를 찾음
		{
			v = i;
			break;
		}

	for (i = 0;i<n;i++)
		if (!selected[i] && (dist[i]<dist[v]))
		{
			v = i;
		}
	return v;
}

int distance_idx[MAX_VERTICES];	//바뀐 distance의 인덱스 값을 가지는 배열

void init_distance_idx(int *distance_idx)
{
	int i;

	for (i = 0; i < MAX_VERTICES; i++)
	{
		if(dist[i] == INF || selected[i] == TRUE)
			distance_idx[i] = 0;
	}
}

//바뀐 distance의 인덱스를 이용 그중에 제일 작은 dist를 찾음 그리고 그 인덱스를 리턴
int min_distance_idx(int *distance_idx, int start)
{
	int i, idx = start; //먼저 시작 인덱스로 초기화
	int min = dist[start];

	for (i = 0;i < MAX_VERTICES;i++)
	{

	}

	for (i = 0;i < MAX_VERTICES;i++)
		if (distance_idx[i] != 0 && min > dist[i])	//0이 아니면서 최솟값을 찾음
		{
			min = dist[i];
			idx = i;
		}

	return idx;
}

void prim(int s, int n)
{

	int i, u, v;

	init(s, n);	//초기화

	for (i = 0;i < n;i++)
	{
		u = get_min_vertex(n);	//최소 가중치를 찾아주는 함수
		selected[u] = TRUE;		//뽑히면 1

		init_distance_idx(distance_idx);	//포문이 한번 돌때마다 0으로 초기화

		int start = u;	// 뽑힌 정점으로 초기화
		for (i = 0;i < n;i++)
		{
			if (selected[i] != TRUE)
			{
				start = i;
				break;
			}
		}

		if (dist[u] == INF)	//갈수 없는 곳이면 종료
			return;

		for (v = 0; v < n; v++)
		{
			if (weight[u][v] != INF)
				if (!selected[v] && weight[u][v] < dist[v])  //하나 뽑힌뒤 dist 업데이트 하는 부분, 정점이 각 가중치가 더 작은거로 초기화 될수 있는데 그 부분이다.
				{
					dist[v] = weight[u][v];
					distance_idx[v] = v;
//					printf("%d  %d\n", u, v);
				}
		}

		int min = min_distance_idx(distance_idx, start);
		printf("(%d, %d)\n", u, min);
	
	}
}

void main()
{
	prim(0, MAX_VERTICES);
}


/*
신장 트리 모양 출력하기 과제!
ex) (1, 0)  (2, 3)  (3, 4)
-> 간선이 연결되는 과정


*/